// ---------------------------------------------------------------------
// THIS FILE IS AUTO-GENERATED BY BEHAVIAC DESIGNER, SO PLEASE DON'T MODIFY IT BY YOURSELF!
// ---------------------------------------------------------------------

#ifndef _BEHAVIAC_CUSTOMIZED_TYPES_H_
#define _BEHAVIAC_CUSTOMIZED_TYPES_H_

#include "behaviac/agent/agent.h"

// -------------------
// Customized enums
// -------------------

enum DriveState
{
	Tracking,
	TrackingLane,
	Following,
	ChangingLane,
	Backing,
	Avoidance,
	Holding,
	InterSectionZone,
	Estop,
	Parking,
	Unknow,
};

DECLARE_BEHAVIAC_ENUM_EX(DriveState, DriveState);
BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER(DriveState);


enum System_Status
{
	good,
	hardware_error,
	sensor_data_error,
	communication_error,
	vehicle_status_error,
	control_status_error,
};

DECLARE_BEHAVIAC_ENUM_EX(System_Status, System_Status);
BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER(System_Status);


enum LaneIdx
{
	Mid,
	L,
	LL,
	R,
	RR,
};

DECLARE_BEHAVIAC_ENUM_EX(LaneIdx, LaneIdx);
BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER(LaneIdx);


enum MAPFlags
{
	Straight_Road,
	Left_turn,
	Right_turn,
	U_turn,
	Tunnel,
	CrossRoad,
	InterSection,
	Avoidence,
	Stop_Line,
};

DECLARE_BEHAVIAC_ENUM_EX(MAPFlags, MAPFlags);
BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER(MAPFlags);


enum Object_Type
{
	VEHICLE,
	PEDESTRIAN,
	ANIMAL,
	BIKE,
	OBSTACLE,
	UNKNOWN,
};

DECLARE_BEHAVIAC_ENUM_EX(Object_Type, Object_Type);
BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER(Object_Type);


// -------------------
// Customized structs
// -------------------

struct Static_Object
{
	Object_Type type_;
	double length;
	double width;
	double hight;
	double x;
	double y;
};

BEHAVIAC_EXTEND_EXISTING_TYPE_EX(Static_Object, true);
BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER(Static_Object);

template< typename SWAPPER >
inline void SwapByteImplement(Static_Object& v)
{
	SwapByteImplement< SWAPPER >(v.type_);
	SwapByteImplement< SWAPPER >(v.length);
	SwapByteImplement< SWAPPER >(v.width);
	SwapByteImplement< SWAPPER >(v.hight);
	SwapByteImplement< SWAPPER >(v.x);
	SwapByteImplement< SWAPPER >(v.y);
}

namespace behaviac
{
	namespace PrivateDetails
	{
		template<>
		inline bool Equal(const Static_Object& lhs, const Static_Object& rhs)
		{
			return &lhs == &rhs;
		}
	}
}

struct Moving_Object : public Static_Object
{
	double vx;
	double vy;
	double relative_vx;
	double relative_vy;
};

BEHAVIAC_EXTEND_EXISTING_TYPE_EX(Moving_Object, true);
BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER(Moving_Object);

template< typename SWAPPER >
inline void SwapByteImplement(Moving_Object& v)
{
	SwapByteImplement< SWAPPER >(v.vx);
	SwapByteImplement< SWAPPER >(v.vy);
	SwapByteImplement< SWAPPER >(v.relative_vx);
	SwapByteImplement< SWAPPER >(v.relative_vy);
	SwapByteImplement< SWAPPER >(v.type_);
	SwapByteImplement< SWAPPER >(v.length);
	SwapByteImplement< SWAPPER >(v.width);
	SwapByteImplement< SWAPPER >(v.hight);
	SwapByteImplement< SWAPPER >(v.x);
	SwapByteImplement< SWAPPER >(v.y);
}

namespace behaviac
{
	namespace PrivateDetails
	{
		template<>
		inline bool Equal(const Moving_Object& lhs, const Moving_Object& rhs)
		{
			return &lhs == &rhs;
		}
	}
}

struct Goal
{
	double x;
	double y;
	double theta;
};

BEHAVIAC_EXTEND_EXISTING_TYPE_EX(Goal, true);
BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER(Goal);

template< typename SWAPPER >
inline void SwapByteImplement(Goal& v)
{
	SwapByteImplement< SWAPPER >(v.x);
	SwapByteImplement< SWAPPER >(v.y);
	SwapByteImplement< SWAPPER >(v.theta);
}

namespace behaviac
{
	namespace PrivateDetails
	{
		template<>
		inline bool Equal(const Goal& lhs, const Goal& rhs)
		{
			return &lhs == &rhs;
		}
	}
}

struct Plan_Frame
{
	MAPFlags mapFlag;
	double min_distance_to_global_route;
	double planned_dis_remain;
	double currentSpeed_ms;
	double currentSteer_deg;
	behaviac::vector<Static_Object> static_obj;
	behaviac::vector<Moving_Object> moving_obj;
	behaviac::vector<Dominator::Point2D> nearObs;
	behaviac::vector<Dominator::Point2D> global_route;
	behaviac::vector<Dominator::Point2D> history_path;
	behaviac::vector<Dominator::Point2D> predict_path;
	Goal* route_goal;
	Goal* lane_goal;
};

BEHAVIAC_EXTEND_EXISTING_TYPE_EX(Plan_Frame, false);
BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER(Plan_Frame);

template< typename SWAPPER >
inline void SwapByteImplement(Plan_Frame& v)
{
	SwapByteImplement< SWAPPER >(v.mapFlag);
	SwapByteImplement< SWAPPER >(v.min_distance_to_global_route);
	SwapByteImplement< SWAPPER >(v.planned_dis_remain);
	SwapByteImplement< SWAPPER >(v.currentSpeed_ms);
	SwapByteImplement< SWAPPER >(v.currentSteer_deg);
	SwapByteImplement< SWAPPER >(v.static_obj);
	SwapByteImplement< SWAPPER >(v.moving_obj);
	SwapByteImplement< SWAPPER >(v.nearObs);
	SwapByteImplement< SWAPPER >(v.global_route);
	SwapByteImplement< SWAPPER >(v.history_path);
	SwapByteImplement< SWAPPER >(v.predict_path);
	SwapByteImplement< SWAPPER >(v.route_goal);
	SwapByteImplement< SWAPPER >(v.lane_goal);
}

namespace behaviac
{
	namespace PrivateDetails
	{
		template<>
		inline bool Equal(const Plan_Frame& lhs, const Plan_Frame& rhs)
		{
			return Equal(lhs.mapFlag, rhs.mapFlag)
				&& Equal(lhs.min_distance_to_global_route, rhs.min_distance_to_global_route)
				&& Equal(lhs.planned_dis_remain, rhs.planned_dis_remain)
				&& Equal(lhs.currentSpeed_ms, rhs.currentSpeed_ms)
				&& Equal(lhs.currentSteer_deg, rhs.currentSteer_deg)
				&& Equal(lhs.static_obj, rhs.static_obj)
				&& Equal(lhs.moving_obj, rhs.moving_obj)
				&& Equal(lhs.nearObs, rhs.nearObs)
				&& Equal(lhs.global_route, rhs.global_route)
				&& Equal(lhs.history_path, rhs.history_path)
				&& Equal(lhs.predict_path, rhs.predict_path)
				&& Equal(lhs.route_goal, rhs.route_goal)
				&& Equal(lhs.lane_goal, rhs.lane_goal);
		}
	}
}

BEHAVIAC_EXTEND_EXISTING_TYPE_EX(Dominator::Point2D, true);
BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER(Dominator::Point2D);

template< typename SWAPPER >
inline void SwapByteImplement(Dominator::Point2D& v)
{
	SwapByteImplement< SWAPPER >(v.x);
	SwapByteImplement< SWAPPER >(v.y);
}

namespace behaviac
{
	namespace PrivateDetails
	{
		template<>
		inline bool Equal(const Dominator::Point2D& lhs, const Dominator::Point2D& rhs)
		{
			return &lhs == &rhs;
		}
	}
}

struct PlanConfig
{
	int frequency;
	int log_level;
	int plannner_type;
	int enable_avoidance;
	double V_width_half;
	double V_front;
	double V_back;
	double lat_safe_margin;
	double lon_safe_margin;
	double min_speed_threshold;
	double static_safe_front;
	double static_safe_back;
	double static_safe_side;
	double predict_time_interval;
	int predict_num;
	double expected_time;
	double max_acceleration;
	double axis_dis;
	double tyre_to_steer;
	double tyre_to_steer_right;
	int display_enabled;
	int myID;
	double follow_dis;
};

BEHAVIAC_EXTEND_EXISTING_TYPE_EX(PlanConfig, false);
BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER(PlanConfig);

template< typename SWAPPER >
inline void SwapByteImplement(PlanConfig& v)
{
	SwapByteImplement< SWAPPER >(v.frequency);
	SwapByteImplement< SWAPPER >(v.log_level);
	SwapByteImplement< SWAPPER >(v.plannner_type);
	SwapByteImplement< SWAPPER >(v.enable_avoidance);
	SwapByteImplement< SWAPPER >(v.V_width_half);
	SwapByteImplement< SWAPPER >(v.V_front);
	SwapByteImplement< SWAPPER >(v.V_back);
	SwapByteImplement< SWAPPER >(v.lat_safe_margin);
	SwapByteImplement< SWAPPER >(v.lon_safe_margin);
	SwapByteImplement< SWAPPER >(v.min_speed_threshold);
	SwapByteImplement< SWAPPER >(v.static_safe_front);
	SwapByteImplement< SWAPPER >(v.static_safe_back);
	SwapByteImplement< SWAPPER >(v.static_safe_side);
	SwapByteImplement< SWAPPER >(v.predict_time_interval);
	SwapByteImplement< SWAPPER >(v.predict_num);
	SwapByteImplement< SWAPPER >(v.expected_time);
	SwapByteImplement< SWAPPER >(v.max_acceleration);
	SwapByteImplement< SWAPPER >(v.axis_dis);
	SwapByteImplement< SWAPPER >(v.tyre_to_steer);
	SwapByteImplement< SWAPPER >(v.tyre_to_steer_right);
	SwapByteImplement< SWAPPER >(v.display_enabled);
	SwapByteImplement< SWAPPER >(v.myID);
	SwapByteImplement< SWAPPER >(v.follow_dis);
}

namespace behaviac
{
	namespace PrivateDetails
	{
		template<>
		inline bool Equal(const PlanConfig& lhs, const PlanConfig& rhs)
		{
			return Equal(lhs.frequency, rhs.frequency)
				&& Equal(lhs.log_level, rhs.log_level)
				&& Equal(lhs.plannner_type, rhs.plannner_type)
				&& Equal(lhs.enable_avoidance, rhs.enable_avoidance)
				&& Equal(lhs.V_width_half, rhs.V_width_half)
				&& Equal(lhs.V_front, rhs.V_front)
				&& Equal(lhs.V_back, rhs.V_back)
				&& Equal(lhs.lat_safe_margin, rhs.lat_safe_margin)
				&& Equal(lhs.lon_safe_margin, rhs.lon_safe_margin)
				&& Equal(lhs.min_speed_threshold, rhs.min_speed_threshold)
				&& Equal(lhs.static_safe_front, rhs.static_safe_front)
				&& Equal(lhs.static_safe_back, rhs.static_safe_back)
				&& Equal(lhs.static_safe_side, rhs.static_safe_side)
				&& Equal(lhs.predict_time_interval, rhs.predict_time_interval)
				&& Equal(lhs.predict_num, rhs.predict_num)
				&& Equal(lhs.expected_time, rhs.expected_time)
				&& Equal(lhs.max_acceleration, rhs.max_acceleration)
				&& Equal(lhs.axis_dis, rhs.axis_dis)
				&& Equal(lhs.tyre_to_steer, rhs.tyre_to_steer)
				&& Equal(lhs.tyre_to_steer_right, rhs.tyre_to_steer_right)
				&& Equal(lhs.display_enabled, rhs.display_enabled)
				&& Equal(lhs.myID, rhs.myID)
				&& Equal(lhs.follow_dis, rhs.follow_dis);
		}
	}
}

#endif // _BEHAVIAC_CUSTOMIZED_TYPES_H_
