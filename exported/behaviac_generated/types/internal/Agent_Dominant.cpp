// -------------------------------------------------------------------------------
// THIS FILE IS ORIGINALLY GENERATED BY THE DESIGNER.
// YOU ARE ONLY ALLOWED TO MODIFY CODE BETWEEN '///<<< BEGIN' AND '///<<< END'.
// PLEASE MODIFY AND REGENERETE IT IN THE DESIGNER FOR CLASS/MEMBERS/METHODS, ETC.
// -------------------------------------------------------------------------------

#include "Agent_Dominant.h"

///<<< BEGIN WRITING YOUR CODE FILE_INIT
int Agent_Dominant::getMax_Speed(const uint8_t mapFlag){
    int max_speed=20;
    switch (mapFlag){
        case MAPFlags::Straight_Road:{
            max_speed=25;break;
        }
        case MAPFlags::Left_turn:{
            max_speed=18;break;
        }
        case MAPFlags::Right_turn:{
            max_speed=18;break;
        }
        case MAPFlags::CrossRoad:{
            max_speed=12;break;
        }
        case MAPFlags::U_turn:{
            max_speed=10;break;
        }
        case MAPFlags::Tunnel:{
            max_speed=10;break;
        }
        case MAPFlags::Avoidence:{
            max_speed=15;break;
        }
        case MAPFlags::InterSection:{
            max_speed=20;break;
        }
        case MAPFlags::Stop_Line:{
            max_speed=15;break;
        }

        default:{
            max_speed=25;break;
        }
    }
    return max_speed;
}

std::string Agent_Dominant::getCurrentState() {
    std::string ret;
    switch (currentState){
        case DriveState ::Tracking:{
            ret="Tracking";
            break;
        }
        case DriveState ::ChangingLane:{
            ret="ChangingLane";
            break;
        }
        case DriveState ::Estop:{
            ret="Estop";
            break;
        }
        case DriveState ::Avoidance:{
            ret="Avoidance";
            break;
        }
        case DriveState ::TrackingLane:{
            ret="TrackingLane";
            break;
        }
        case DriveState ::Backing:{
            ret="Backing";
            break;
        }
        case DriveState ::Following:{
            ret="Following";
            break;
        }
        default:{
            ret="Tracking";
            break;

        }
    }
    return ret;
}

bool Agent_Dominant::initLCM() {
	if (!PlannerLCM.good()) {
		PlannerLogger->error("LCM initial failed");
		return false;
	}

	PlannerLCM.subscribe("Slam", &Message_Handler::handle_Slam_Message, &handlerObject);
	PlannerLCM.subscribe("GPS", &Message_Handler::handle_GPS_Message, &handlerObject);
	PlannerLCM.subscribe("CANMsg", &Message_Handler::handle_CANMsg_Message, &handlerObject);
	PlannerLCM.subscribe("HAD", &Message_Handler::handle_HDMap_Message, &handlerObject);

//    PlannerLCM.subscribe("Ibeo", &Message_Handler::handle_Ibeo_Message, &handlerObject);
    PlannerLCM.subscribe("Ibeo", &Message_Handler::handle_IbeoVector_Message, &handlerObject);


    //    PlannerLCM.subscribe("Stopline",&Message_Handler::handle_StopLine_Message,&handlerObject);
    //    PlannerLCM.subscribe("Trafficlight",&Message_Handler::handle_Traffic_light_Message,&handlerObject);
    //    PlannerLCM.subscribe("MobileEye",&Message_Handler::handle_MobileEye_Message,&handlerObject);
    //    PlannerLCM.subscribe("Radar",&Message_Handler::handle_Radar_Message,&handlerObject);
    /*************************************************************************************/
    /**************************************V2X********************************************/
    /*************************************************************************************/
    PlannerLCM.subscribe("OtherVehicleData_list", &Message_Handler::handle_OtherVehiclesData_Message, &handlerObject);
    PlannerLCM.subscribe("IncomingEventData", &Message_Handler::handle_InCommingEvent_Message, &handlerObject);



	return true;
}
#ifndef _WIN32
bool Agent_Dominant::initConfig(const std::string& fileName) {
	Planner_Config_Reader configReader;
	if (!configReader.Read_Config(fileName)){
		PlannerLogger->error("Reading Configure failed,using default values");
		return false;
	}
	planConfig=configReader.getConfig();
	return true;
}
#else
bool Agent_Dominant::initConfig(_In_ LPCWSTR xmlFilePath) {
	Planner_Config_Reader configReader;
	if (!configReader.Read_Config(xmlFilePath)){
		PlannerLogger->error("Reading Configure failed,using default values");
		return false;
	}
	planConfig = configReader.getConfig();
	return true;
}
#endif
bool Agent_Dominant::init() {
	bool readSuccess = true;
#ifdef _WIN32
	readSuccess = initConfig(L"Planner.config");
#else
	readSuccess = initConfig("Planner.config");
#endif
	bool initLcmSuccess = initLCM();
	PlannerLogger->set_level(static_cast<spdlog::level::level_enum>(planConfig.log_level));
	return readSuccess&&initLcmSuccess;
}

void Agent_Dominant::Set_New_Flags() {
    lock_.Lock();
    isNewGPS=handlerObject.isNewGPS;
    handlerObject.isNewGPS=false;
    isNewCAN=handlerObject.isNewCAN;
    handlerObject.isNewCAN=false;
    isNewSlam=handlerObject.isNewSlam;
    handlerObject.isNewSlam=false;
    isNewEvent=handlerObject.isNewEvent;
    handlerObject.isNewEvent=false;
    isNewOtherCar=handlerObject.isNewOtherCar;
    handlerObject.isNewOtherCar=false;
    lock_.UnLock();
}

DriveState Agent_Dominant:: Handle_5G(){
    PacketGPS mGPS=rawFrame.GPS;
    /*********************************************************/
    if(isNewEvent){
        lock_.Lock();
        incomingEventData=handlerObject.incomingEventData;
        lock_.UnLock();
        if(incomingEventData.eventType.causeCode==10){//HazardousLocation_ObstacleOnTheRoad
            global2_Local(EventDis, eventX, eventY, incomingEventData.eventPosition.lat, incomingEventData.eventPosition.lon, mGPS.lat, mGPS.lon, mGPS.heading);
            double elapseDis = (mGPS.referenceTime -incomingEventData.eventDetectionTime)*mGPS.speed;
            EventDis_when_received=EventDis+elapseDis;
            if(EventDis_when_received>22){
                m5Gstate=DriveState ::Estop;
            }else{
                if(firstEvent){
                    m5Gstate=DriveState ::ChangingLane;
                    firstEvent=false;
                }
            }
        }
    } else{
        if (incomingEventData.eventPosition.lat)
            global2_Local(EventDis, eventX, eventY, incomingEventData.eventPosition.lat, incomingEventData.eventPosition.lon, mGPS.lat, mGPS.lon, mGPS.heading);
    }
    /*********************************************************/
    /*********************************************************/
    /*********************************************************/

    if(isNewOtherCar){
        lock_.Lock();
        otherVehicleData_list=handlerObject.otherVehicleData_list;
        lock_.UnLock();
        if (otherVehicleData_list.numOfVehicles){
            global2_Local(CarDis,othercarX , othercarY, otherVehicleData_list.vehicle[0].lat, otherVehicleData_list.vehicle[0].lon, mGPS.lat, mGPS.lon, mGPS.heading);
            m5Gstate = DriveState ::Following;
        }
    }else{
        if (otherVehicleData_list.vehicle.size())
            global2_Local(CarDis,othercarX , othercarY, otherVehicleData_list.vehicle[0].lat, otherVehicleData_list.vehicle[0].lon, mGPS.lat, mGPS.lon, mGPS.heading);
    }
    /*********************************************************/
      return m5Gstate;
}



///<<< END WRITING YOUR CODE

Agent_Dominant::Agent_Dominant()
{
	currentLane = Mid;
	currentState = DriveState::Tracking;
	lastState = DriveState::Tracking;
	m5Gstate = DriveState::Tracking;
	min_collision_time = -1;
	systemStatus = good;
///<<< BEGIN WRITING YOUR CODE CONSTRUCTOR
    environment.lane_goal=new Goal();
    environment.route_goal=new Goal();
	speed_request = 0;
    WorldParam para;
    int Indx_Num = (para.right - para.left) / para.gridsize;
    int Indy_Num = (para.top - para.bottom) / para.gridsize;
    gMap.resize(Indx_Num);
    for (size_t i = 0; i < gMap.size(); ++i){
        gMap[i].resize(Indy_Num);
    }
///<<< END WRITING YOUR CODE
}

Agent_Dominant::~Agent_Dominant()
{
///<<< BEGIN WRITING YOUR CODE DESTRUCTOR
    delete environment.lane_goal;
    environment.lane_goal= nullptr;
    delete environment.route_goal;
    environment.route_goal= nullptr;
///<<< END WRITING YOUR CODE
}

behaviac::EBTStatus Agent_Dominant::Action()
{
///<<< BEGIN WRITING YOUR CODE Action
    //send path
    last_publish_time=high_resolution_clock::now();
    PlannerLCM.publish("Plan",&path_publish);
    PlannerLogger->info("Agent_Dominant.cpp,line {},sent path",__LINE__);
	return behaviac::BT_SUCCESS;
///<<< END WRITING YOUR CODE
}

behaviac::EBTStatus Agent_Dominant::Avoidance()
{
///<<< BEGIN WRITING YOUR CODE Avoidance
    if(min_collision_time_on_plannedpath>0){
        if(min_collision_time_on_plannedpath>0&&min_collision_time_on_plannedpath<1.5)
            return behaviac::BT_FAILURE;
    }
    if(isPathRunout(6.0)){
        return behaviac::BT_SUCCESS;
    }
	return behaviac::BT_RUNNING;
///<<< END WRITING YOUR CODE
}

behaviac::EBTStatus Agent_Dominant::ChangingLane()
{
///<<< BEGIN WRITING YOUR CODE ChangingLane
    if(!is_change_finished())//TODO
	  return behaviac::BT_RUNNING;
    else {
        if(currentLane==Mid)
            currentLane=L;
        else if(currentLane==L){
            currentLane=Mid;
        }
        if(m5Gstate==DriveState::ChangingLane){
            m5Gstate=DriveState::Tracking;
        }
        sent_interval=time_since_last;
        return behaviac::BT_SUCCESS;
    }
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::collision_time_feasibleforchange()
{
///<<< BEGIN WRITING YOUR CODE collision_time_feasibleforchange
    bool c= min_collision_time_on_plannedpath>1.0&&min_collision_time_on_plannedpath<4.0;
    if(c){
        speed_request=std::min(speed_request,20);
        return true;
    }
    return false;
///<<< END WRITING YOUR CODE
}

behaviac::EBTStatus Agent_Dominant::Estop()
{
///<<< BEGIN WRITING YOUR CODE Estop
    speed_publish.speedRequest=0;
    PlannerLCM.publish("SpdReq",&speed_publish);
    last_publish_time=high_resolution_clock::now();
    return behaviac::BT_SUCCESS;
///<<< END WRITING YOUR CODE
}

void Agent_Dominant::find_5G_EstopSpeed()
{
///<<< BEGIN WRITING YOUR CODE find_5G_EstopSpeed
    double v_ms=ComPuteStopSpeed(EventDis);
    speed_request= static_cast<int>(v_ms*3.6);
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::find_5G_FollowingPath()
{
///<<< BEGIN WRITING YOUR CODE find_5G_FollowingPath
    Pointvector p;
    for(size_t i=0;i<frontcarX.size();++i){
      p.push_back({frontcarX[i],frontcarY[i]});
    }
    Arc_Length_based_Curve frontcarPath(p);
    path_publish.lengthOfPlan=frontcarPath.size();
    path_publish.pathPoints.clear();
    path_publish.pathPointx.clear();
    path_publish.pathPointy.clear();
    for(size_t i=0;i<frontcarPath.size();++i){
        path_publish.pathPoints.push_back(frontcarPath.sps_controlPoint[i]);
        path_publish.pathPointx.push_back(frontcarPath.spx_controlPoint[i]);
        path_publish.pathPointy.push_back(frontcarPath.spy_controlPoint[i]);
    }
	return true;
///<<< END WRITING YOUR CODE
}

void Agent_Dominant::find_5G_FollowingSpeed()
{
///<<< BEGIN WRITING YOUR CODE find_5G_FollowingSpeed
    double SetDis=15.0;//TODO idx=0;add to config
    const double acc=2.0;
    const double deacc=2.5;
    double v_ms=TrackingFrontCarSpeed(CarDis,SetDis,otherVehicleData_list.vehicle[0].speed,environment.currentSpeed_ms,acc,deacc);
    speed_request= static_cast<int>(v_ms*3.6);
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::find_advice_speed()
{
///<<< BEGIN WRITING YOUR CODE find_advice_speed
    int speed_Max=std::min(static_cast<int>(rawFrame.canMsg.speed+3), speed_limit_kmh);
	speed_Max = std::max(0,speed_Max);
    int advice_speed=speed_Max;
    if(min_collision_time==999){
        advice_speed=0;
    }else if(min_collision_time>0&&min_collision_time<planConfig.expected_time){
        advice_speed=min_collision_time*environment.currentSpeed_ms/planConfig.expected_time*3.6;
    }
    speed_request=std::min(speed_Max,advice_speed);
	return true;
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::find_change_path()
{
///<<< BEGIN WRITING YOUR CODE find_change_path
    PacketPlan temp;
    bool found=false;
    switch (currentLane){
        case LaneIdx ::Mid:{
            Pointvector lane;
            for(size_t i=0;i<40;++i){
                double x=(rawFrame.HDMap.lane2x[i]+rawFrame.HDMap.lane1x[i])/2;
                double y=(rawFrame.HDMap.lane2y[i]+rawFrame.HDMap.lane1y[i])/2;
                lane.push_back(Dominator::Point2D(x,y));
            }
            Arc_Length_based_Curve rlane(lane,0.9);
            rlane.make_curve();
            Candidate_select_planner planner;
            planner.set_generator_config(0.5,1.5,10);
            planner.set_selector_config(1.0,0.8,1.0);
            planner.Candidate_path_generator(rlane);
            found= planner.Candidate_path_selector(gMap);
            Trajectory plannedPath= planner.getPath();
            for(size_t i=0;i<plannedPath.size();i+=10){
                temp.pathPoints.push_back(0.3*i);//TODO interval=0.3;
                temp.pathPointx.push_back(plannedPath.get(i).x);
                temp.pathPointy.push_back(plannedPath.get(i).y);

            }
            temp.lengthOfPlan=path_publish.pathPoints.size();
            break;
        }
        case LaneIdx ::L:{
            Arc_Length_based_Curve glo(environment.global_route);
            glo.make_curve();
            Candidate_select_planner planner;
            planner.set_generator_config(0.5,1.5,10);
            planner.set_selector_config(1.0,0.8,1.0);
            planner.Candidate_path_generator(glo);
            found= planner.Candidate_path_selector(gMap);
            Trajectory plannedPath= planner.getPath();
            for(size_t i=0;i<plannedPath.size();i+=10){
                temp.pathPoints.push_back(0.3*i);
                temp.pathPointx.push_back(plannedPath.get(i).x);
                temp.pathPointy.push_back(plannedPath.get(i).y);

            }
            temp.lengthOfPlan=path_publish.pathPoints.size();
            break;
        }

    }
    if(found)
        path_publish=temp;
     return found;
///<<< END WRITING YOUR CODE
}

behaviac::EBTStatus Agent_Dominant::FollowingFrontCar()
{
///<<< BEGIN WRITING YOUR CODE FollowingFrontCar
    if(time_since_last>planConfig.frequency){
        find_5G_FollowingPath();
        sent_interval=time_since_last;
        return behaviac::BT_SUCCESS;
    }
    return behaviac::BT_RUNNING;

///<<< END WRITING YOUR CODE
}

void Agent_Dominant::HandleFrame()
{
///<<< BEGIN WRITING YOUR CODE HandleFrame
    /*****************************************************************************/
    Set_New_Flags();
    /*****************************************************************************/
    Handle_5G();
    UpdateFrontCarHistory(isNewOtherCar,frontcarlat,frontcarlon,rawFrame.GPS.lat,rawFrame.GPS.lon,35);
    FrontCarGlobal2Local(frontcarlat,frontcarlon,frontcarX,frontcarY,rawFrame.GPS);
    /*****************************************************************************/
    /*****************************************************************************/

    time_since_last=duration_cast<milliseconds>(high_resolution_clock::now()-last_publish_time).count();
    time_since_last_spd=duration_cast<milliseconds>(high_resolution_clock::now()-last_publish_time_spd).count();
    rawFrame=handlerObject.getRawFrame();
    min_collision_time=-1.0;//TODO
    min_collision_dis=999.0;//TODO
    min_collision_time_on_plannedpath=-1.0;//TODO
    environment.mapFlag = static_cast<MAPFlags>(rawFrame.HDMap.MapFlag[0]);
    speed_publish.mapFlag=environment.mapFlag;
    speed_limit_kmh=getMax_Speed(environment.mapFlag);
    environment.currentSpeed_ms=static_cast<double>(rawFrame.canMsg.speed) / 3.6;
    environment.currentSteer_deg=rawFrame.canMsg.steer;
    /*****************************************************************************/
    environment.history_path.clear();
    for (size_t n = 0; n < rawFrame.Slam.pathPointx.size(); ++n) {
        environment.history_path.push_back(Dominator::Point2D(rawFrame.Slam.pathPointx[n], rawFrame.Slam.pathPointy[n]));
    }
    Trajectory his(environment.history_path);
    environment.planned_dis_remain =his.path_length_remain();
    /*****************************************************************************/
    environment.global_route.clear();
    for (size_t n = 0; n < 100; ++n) {//TODO gpspath长度100 ? 250
        if(rawFrame.HDMap.gpsy[n]==0)
            break;
        environment.global_route.push_back(Dominator::Point2D(rawFrame.HDMap.gpsx[n], rawFrame.HDMap.gpsy[n]));
    }
    Trajectory glo(environment.global_route);
    glo.nearest_point(environment.min_distance_to_global_route);
    /*****************************************************************************/
    //TODO objs
    PlanAlgorithm::GridMap(rawFrame.ibeo_Fv,gMap);
    PlanAlgorithm::GridMap(rawFrame.ibeo_Lv,gMap);
    PlanAlgorithm::GridMap(rawFrame.ibeo_Rv,gMap);
    //TODO nearobs
  //  environment.static_obj.clear();
  //  environment.moving_obj.clear();
    std::vector<double> nearobstime;
    PlanAlgorithm::FindNearObstacle_with_time(his.get_path(),gMap,nearobstime,environment.currentSpeed_ms);
    if(nearobstime.size()){
        min_collision_time_on_plannedpath=*std::min_element(nearobstime.begin(),nearobstime.end());
    }

    if(environment.global_route.size()>2&&environment.global_route.back().y){
        environment.route_goal->x=environment.global_route.back().x;
        environment.route_goal->y=environment.global_route.back().y;
        int N=environment.global_route.size()-2;
        Dominator::Point2D p=environment.global_route[N];
        environment.route_goal->theta=std::atan2(environment.route_goal->y-p.y,environment.route_goal->x-p.x);
    }

    is_on_predict_path(min_collision_time);
  //  is_on_planned_path(min_collision_time_on_plannedpath);
    /*****************************************************************************/
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::I_need_to_changelane()
{
///<<< BEGIN WRITING YOUR CODE I_need_to_changelane
   return m5Gstate==DriveState ::ChangingLane||collision_time_feasibleforchange();
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::I_want_to_changlane()
{
///<<< BEGIN WRITING YOUR CODE I_want_to_changlane
    return dis_after_change>15.0;
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::Im_able_to_changelane()
{
///<<< BEGIN WRITING YOUR CODE Im_able_to_changelane
    bool islow=is_speed_lower_than(25);
    bool islane=is_other_lane();
    bool isfree=is_other_lane_free();
    bool findpath=find_change_path();
	return islow&&islane&&isfree&&findpath;
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::is_5G_Event()
{
///<<< BEGIN WRITING YOUR CODE is_5G_Event
	return isNewEvent;
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::is_5G_Front_Car()
{
///<<< BEGIN WRITING YOUR CODE is_5G_Front_Car
	return isNewOtherCar;
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::is_change_finished()
{
///<<< BEGIN WRITING YOUR CODE is_change_finished
    bool runout=isPathRunout(10.0);
	return runout;//
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::is_on_planned_path(double& collsion_time)
{
///<<< BEGIN WRITING YOUR CODE is_on_planned_path
	return false;//TODO
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::is_on_predict_path(double& collision_time)
{
///<<< BEGIN WRITING YOUR CODE is_on_predict_path
    bool collision=false;
    const PacketIbeoVector& ibeo=rawFrame.ibeo_Fv;
    if(rawFrame.canMsg.speed<=8) {
        for(int i=0;i<ibeo.lengthOfContour;i+=2){
            if(abs(ibeo.ibcontourx[i])<planConfig.V_width_half+planConfig.static_safe_side
               &&ibeo.ibcontoury[i]>planConfig.V_back
               &&ibeo.ibcontoury[i]<planConfig.V_front+planConfig.static_safe_front+environment.currentSpeed_ms*5){
                min_collision_time=999;
                return true;
            }
        }
    }
    else {//有车速
        double str=rawFrame.canMsg.steer*deg2rad;
        if(str==0)str=deg2rad;
        double tyre_angle=str/planConfig.tyre_to_steer;
        double omega;
        double R=planConfig.axis_dis/tan(tyre_angle);
        omega=environment.currentSpeed_ms/R;
        double move_safe_side = planConfig.static_safe_side + environment.currentSpeed_ms*0.05;

        Dominator::Point2D circle_center(-R, 0);
        double minTheta=999;
        int min_idx=0;
        double MaxTheta = omega * planConfig.predict_num * planConfig.predict_time_interval;
        if (abs(environment.currentSteer_deg) > 40)
            MaxTheta *= 0.7;
        if (R > 0) {
            double Ra = R + planConfig.V_width_half + move_safe_side;
            double Rb = R - planConfig.V_width_half - move_safe_side;
            minTheta = m_2PI;
            for (int i = 0; i < ibeo.lengthOfContour; i+=2) {
                if (ibeo.ibcontoury[i] == 0)
                    break;
                double dis = distance(circle_center, Dominator::Point2D(ibeo.ibcontourx[i], ibeo.ibcontoury[i]));
                if (dis < Ra && dis > Rb) {
                    double the = atan2(ibeo.ibcontoury[i], ibeo.ibcontourx[i] + R);
                    if (the < MaxTheta) {
                        collision = true;
                        if (the < minTheta) {
                            minTheta = the;
                            min_idx = i;
                        }//end min
                    }//end theta
                }//end dis
            }//end ibeo
        }//end R>0
        else {
            double Ra = -R + planConfig.V_width_half + move_safe_side;
            double Rb = -R - planConfig.V_width_half - move_safe_side;
            minTheta = 0;
            for (size_t i=0;i<ibeo.lengthOfContour;i+=2) {
                if (ibeo.ibcontoury[i] == 0)
                    break;
                double dis = distance(circle_center, Dominator::Point2D(ibeo.ibcontourx[i], ibeo.ibcontoury[i]));
                if (dis < Ra && dis > Rb) {
                    double the = atan2(ibeo.ibcontoury[i], ibeo.ibcontourx[i] + R);
                    if (the > MaxTheta + m_PI && the < m_PI) {
                        collision = true;
                        if (the > minTheta) {
                            min_idx = i;
                            minTheta = the;
                        }

                    }//end for theta
                }//end for dis<Ra&&dis>Rb
            }//end for ibeo
        }//end for R>0
        min_collision_time = abs(ibeo.ibcontoury[min_idx] / environment.currentSpeed_ms);
    }//end for speed<8
    return collision;
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::is_other_lane()
{
///<<< BEGIN WRITING YOUR CODE is_other_lane
    if(currentLane==Mid)
        return (std::fabs(rawFrame.HDMap.lane1x[0])<8.0f);
    if(currentLane==L)
	    return (std::fabs(rawFrame.HDMap.lane2x[0])<4.0f);
	return false;
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::is_other_lane_free()
{
///<<< BEGIN WRITING YOUR CODE is_other_lane_free
	return true;//TODO
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::is_speed_lower_than(const double spd)
{
///<<< BEGIN WRITING YOUR CODE is_speed_lower_than
    //kmh
	return rawFrame.canMsg.speed<spd;
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::is_stopline_close()
{
///<<< BEGIN WRITING YOUR CODE is_stopline_close
	return false;
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::is_traffice_red()
{
///<<< BEGIN WRITING YOUR CODE is_traffice_red
	return false;
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::isEstop()
{
///<<< BEGIN WRITING YOUR CODE isEstop
    if(min_collision_time>0&&min_collision_time<1.5)
      return true;
	return false;//TODO
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::isPathRunout(const double dis_set)
{
///<<< BEGIN WRITING YOUR CODE isPathRunout
	return environment.planned_dis_remain<dis_set;
///<<< END WRITING YOUR CODE
}

behaviac::EBTStatus Agent_Dominant::Move()
{
///<<< BEGIN WRITING YOUR CODE Move
    speed_publish.speedRequest=speed_request;
    if(time_since_last_spd>50){
        last_publish_time_spd=high_resolution_clock::now();
        PlannerLCM.publish("SpdReq",&speed_publish);
    }

	return behaviac::BT_SUCCESS;
///<<< END WRITING YOUR CODE
}

bool Agent_Dominant::no_collision_or_collision_far_away()
{
///<<< BEGIN WRITING YOUR CODE no_collision_or_collision_far_away
   return min_collision_time_on_plannedpath==-1||min_collision_time_on_plannedpath>5.0;
///<<< END WRITING YOUR CODE
}

System_Status Agent_Dominant::System_Check()
{
///<<< BEGIN WRITING YOUR CODE System_Check
	return System_Status::good;
///<<< END WRITING YOUR CODE
}

behaviac::EBTStatus Agent_Dominant::Tracking()
{
///<<< BEGIN WRITING YOUR CODE Tracking
    dis_after_change=0;
if(time_since_last>planConfig.frequency){
    Arc_Length_based_Curve arc_base_path(environment.global_route);
    path_publish.lengthOfPlan=arc_base_path.size();
    path_publish.pathPoints.clear();
    path_publish.pathPointx.clear();
    path_publish.pathPointy.clear();
    for(size_t i=0;i<arc_base_path.size();++i){
        path_publish.pathPoints.push_back(arc_base_path.sps_controlPoint[i]);
        path_publish.pathPointx.push_back(arc_base_path.spx_controlPoint[i]);
        path_publish.pathPointy.push_back(arc_base_path.spy_controlPoint[i]);
    }
    sent_interval=time_since_last;
    return behaviac::BT_SUCCESS;
}
    return behaviac::BT_RUNNING;
///<<< END WRITING YOUR CODE
}

behaviac::EBTStatus Agent_Dominant::TrackingLane()
{
///<<< BEGIN WRITING YOUR CODE TrackingLane
    if(time_since_last>planConfig.frequency){
        dis_after_change+=environment.currentSpeed_ms*0.1;
        Pointvector lane;
        for(size_t i=0;i<40;i+=2){
            double x=(rawFrame.HDMap.lane2x[i]+rawFrame.HDMap.lane3x[i])/2;
            double y=(rawFrame.HDMap.lane2y[i]+rawFrame.HDMap.lane3y[i])/2;
            lane.push_back(Dominator::Point2D(x,y));
        }
        Arc_Length_based_Curve arc_base_path(lane,0.9);
        path_publish.lengthOfPlan=arc_base_path.size();
        path_publish.pathPoints.clear();
        path_publish.pathPointx.clear();
        path_publish.pathPointy.clear();
        for(size_t i=0;i<arc_base_path.size();++i){
            path_publish.pathPoints.push_back(arc_base_path.sps_controlPoint[i]);
            path_publish.pathPointx.push_back(arc_base_path.spx_controlPoint[i]);
            path_publish.pathPointy.push_back(arc_base_path.spy_controlPoint[i]);
        }
        sent_interval=time_since_last;
        return behaviac::BT_SUCCESS;
    }
    return behaviac::BT_RUNNING;
///<<< END WRITING YOUR CODE
}


///<<< BEGIN WRITING YOUR CODE FILE_UNINIT

///<<< END WRITING YOUR CODE
